{"version":3,"sources":["webpack://mapboxGlDrawSnapMode/webpack/universalModuleDefinition","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/helpers/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bbox-polygon/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/invariant/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-point-in-polygon/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/meta/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/quickselect.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/rbush.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-segment/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-intersect/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/polygon-to-line/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-disjoint/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/distance/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bearing/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/destination/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/nearest-point-on-line/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/midpoint/main.es.js","webpack://mapboxGlDrawSnapMode/./src/utils/index.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_point.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_line.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_polygon.js","webpack://mapboxGlDrawSnapMode/./src/utils/customDrawStyles.js","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/constants\"","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\"","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/lib/theme\"","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\"","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/modes/draw_point\"","webpack://mapboxGlDrawSnapMode/external \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\"","webpack://mapboxGlDrawSnapMode/webpack/bootstrap","webpack://mapboxGlDrawSnapMode/webpack/startup","webpack://mapboxGlDrawSnapMode/webpack/runtime/compat get default export","webpack://mapboxGlDrawSnapMode/webpack/runtime/define property getters","webpack://mapboxGlDrawSnapMode/webpack/runtime/hasOwnProperty shorthand","webpack://mapboxGlDrawSnapMode/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__759__","__WEBPACK_EXTERNAL_MODULE__583__","__WEBPACK_EXTERNAL_MODULE__227__","__WEBPACK_EXTERNAL_MODULE__556__","__WEBPACK_EXTERNAL_MODULE__391__","__WEBPACK_EXTERNAL_MODULE__403__","earthRadius","factors","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","feature","geometry","properties","options","isObject","Error","bbox","id","undefined","constructor","Object","validateBBox","validateId","feat","type","point","coordinates","Array","isArray","length","isNumber","polygon","i","ring","j","featureCollection","features","fc","multiLineString","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","Math","PI","degreesToRadians","num","isNaN","input","forEach","indexOf","west","Number","south","east","north","lowLeft","getCoord","obj","getCoords","containsNumber","inRing","pt","ignoreBoundary","isInside","slice","xi","yi","xj","yj","polys","inBBox","insidePoly","inHole","k","coordEach","geojson","callback","excludeWrapCoord","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","coordinate","quickselectStep","arr","left","right","compare","n","m","z","log","s","exp","sd","sqrt","max","floor","min","t","swap","tmp","defaultCompare","a","b","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","clear","findItem","item","items","equalsFn","calcBBox","node","toBBox","distBBox","children","p","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","mid","stack","pop","push","prototype","all","_all","data","search","result","len","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","remove","parent","index","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","topLeft","topRight","turfBBox","coord","tree","json","results","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","unique","intersect","match","key","coordsToLine","geom","name","getType","lines","isPointOnLine","lineString","isPointOnLineSegment","isLineInPoly","LineSegmentStart","LineSegmentEnd","Point","dxc","dyc","dxl","dyl","abs","feature1","feature2","boolean","flatten1","flatten2","geom1","geom2","pair1","pair2","lineString1","lineString2","isLineOnLine","i2","isPolyInPoly","disjoint","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","sin","cos","atan2","bearing","start","end","final","bear","calculateFinalBearing","lon1","lon2","origin","longitude1","latitude1","bearing_rad","latitude2","asin","closestPt","dist","line","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","intersectPt","location","point1","point2","heading","IDS","addPointTovertices","map","vertices","forceInclusion","getCanvas","w","width","h","project","x","y","createSnapList","draw","currentFeature","canvas","cUR","cLL","getAll","snapList","bboxAsPolygon","unproject","toArray","bboxPolygon","flat","addVerticesTovertices","isCurrentFeature","booleanDisjoint","geojsonTypes","calcClosestLayer","lngLat","layers","closestLayer","layer","P","lng","lat","isMarker","isPolygon","latlngs","latlng","polygonToLine","nearestPoint","nearestPointOnLine","calcLayerDistances","snap","state","e","minDistance","snapLatLng","latitude","zoomLevel","latitudeRadians","verticalPx","horizontalPx","verticals","horizontals","originalEvent","altKey","showVerticalSnapLine","showHorizontalSnapLine","keys","snapOptions","A","B","C","distanceAC","distanceBC","closestVertexLatLng","shortestDistance","snapToMidPoints","midpoint","distanceMC","checkPrioritiySnapping","snapPx","getZoom","guides","nearestGuidline","vertex","find","px","py","lngLatTop","lngLatBottom","verticalGuide","updateCoordinate","horizontalGuide","getGuideFeature","isSnapGuide","shouldHideGuide","SnapPointMode","DrawPoint","onSetup","newFeature","addFeature","selectedFeatures","getSelected","clearSelectedFeatures","doubleClickZoom","_ctx","api","moveendCallback","optionsChangedCallBAck","on","onClick","snappedLng","snappedLat","onMouseMove","lastVertex","updateUIClasses","mouse","cursors","toDisplayFeatures","display","onStop","deleteFeature","silent","off","SnapLineMode","DrawLine","currentVertexPosition","changeMode","modes","featureIds","SnapPolygonMode","DrawPolygon","modifiedDefaultStyles","theme","defaultStyle","filter","layout","paint","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","getter","__esModule","d","definition","o","defineProperty","enumerable","get","prop","hasOwnProperty","call","r","Symbol","toStringTag","value"],"mappings":"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","file":"mapbox-gl-draw-snap-mode.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@mapbox/mapbox-gl-draw/src/constants\"), require(\"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_point\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\"), require(\"@mapbox/mapbox-gl-draw/src/lib/theme\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@mapbox/mapbox-gl-draw/src/constants\", \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\", \"@mapbox/mapbox-gl-draw/src/modes/draw_point\", \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\", \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\", \"@mapbox/mapbox-gl-draw/src/lib/theme\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mapboxGlDrawSnapMode\"] = factory(require(\"@mapbox/mapbox-gl-draw/src/constants\"), require(\"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_point\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\"), require(\"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\"), require(\"@mapbox/mapbox-gl-draw/src/lib/theme\"));\n\telse\n\t\troot[\"mapboxGlDrawSnapMode\"] = factory(root[\"@mapbox/mapbox-gl-draw/src/constants\"], root[\"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\"], root[\"@mapbox/mapbox-gl-draw/src/modes/draw_point\"], root[\"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\"], root[\"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\"], root[\"@mapbox/mapbox-gl-draw/src/lib/theme\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__759__, __WEBPACK_EXTERNAL_MODULE__583__, __WEBPACK_EXTERNAL_MODULE__227__, __WEBPACK_EXTERNAL_MODULE__556__, __WEBPACK_EXTERNAL_MODULE__391__, __WEBPACK_EXTERNAL_MODULE__403__) {\nreturn ","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { polygon, validateBBox } from '@turf/helpers';\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @name bboxPolygon\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    validateBBox(bbox);\n    // Convert BBox positions to Numbers\n    // No performance loss for including Number()\n    // https://github.com/Turfjs/turf/issues/1119\n    var west = Number(bbox[0]);\n    var south = Number(bbox[1]);\n    var east = Number(bbox[2]);\n    var north = Number(bbox[3]);\n\n    if (bbox.length === 6) throw new Error('@turf/bbox-polygon does not support BBox with 6 positions');\n\n    var lowLeft = [west, south];\n    var topLeft = [west, north];\n    var topRight = [east, north];\n    var lowRight = [east, south];\n\n    return polygon([[\n        lowLeft,\n        lowRight,\n        topRight,\n        topLeft,\n        lowLeft\n    ]]);\n}\n\nexport default bboxPolygon;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord, getCoords } from '@turf/invariant';\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if (typeof options !== 'object') throw new Error('options is invalid');\n    var ignoreBoundary = options.ignoreBoundary;\n\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n}\n\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\nexport default booleanPointInPolygon;\n","import { feature, lineString } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, featureProperties, featureBBox, featureId);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, multiFeatureIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, multiFeatureIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature$$1, function (previousCoords, currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0);\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex);\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce };\n","function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","import { featureCollection, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { feature, featureCollection, point } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","import { getCoords, getType } from '@turf/invariant';\nimport { featureCollection, isObject, lineString, multiLineString } from '@turf/helpers';\n\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} polygon Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nfunction polygonToLine(polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var properties = options.properties;\n\n    // Variables\n    var geom = getType(polygon);\n    var coords = getCoords(polygon);\n    properties = properties || polygon.properties || {};\n\n    if (!coords.length) throw new Error('polygon must contain coordinates');\n\n    switch (geom) {\n    case 'Polygon':\n        return coordsToLine(coords, properties);\n    case 'MultiPolygon':\n        var lines = [];\n        coords.forEach(function (coord) {\n            lines.push(coordsToLine(coord, properties));\n        });\n        return featureCollection(lines);\n    default:\n        throw new Error('geom ' + geom + ' not supported');\n    }\n}\n\nfunction coordsToLine(coords, properties) {\n    if (coords.length > 1) return multiLineString(coords, properties);\n    return lineString(coords[0], properties);\n}\n\nexport default polygonToLine;\n","import booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { flattenEach } from '@turf/meta';\nimport lineIntersect from '@turf/line-intersect';\nimport polygonToLine from '@turf/polygon-to-line';\n\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var boolean;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (boolean === false) return false;\n            boolean = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return boolean;\n}\n\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n    case 'Point':\n        switch (geom2.type) {\n        case 'Point':\n            return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case 'LineString':\n            return !isPointOnLine(geom2, geom1);\n        case 'Polygon':\n            return !booleanPointInPolygon(geom1, geom2);\n        }\n        /* istanbul ignore next */\n        break;\n    case 'LineString':\n        switch (geom2.type) {\n        case 'Point':\n            return !isPointOnLine(geom1, geom2);\n        case 'LineString':\n            return !isLineOnLine(geom1, geom2);\n        case 'Polygon':\n            return !isLineInPoly(geom2, geom1);\n        }\n        /* istanbul ignore next */\n        break;\n    case 'Polygon':\n        switch (geom2.type) {\n        case 'Point':\n            return !booleanPointInPolygon(geom2, geom1);\n        case 'LineString':\n            return !isLineInPoly(geom1, geom2);\n        case 'Polygon':\n            return !isPolyInPoly(geom2, geom1);\n        }\n    }\n}\n\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, point) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], point.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\nfunction isLineInPoly(polygon, lineString) {\n    for (var i = 0; i < lineString.coordinates.length; i++) {\n        if (booleanPointInPolygon(lineString.coordinates[i], polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var i = 0; i < feature1.coordinates[0].length; i++) {\n        if (booleanPointInPolygon(feature1.coordinates[0][i], feature2)) {\n            return true;\n        }\n    }\n    for (var i2 = 0; i2 < feature2.coordinates[0].length; i2++) {\n        if (booleanPointInPolygon(feature2.coordinates[0][i2], feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\nfunction isPointOnLineSegment(LineSegmentStart, LineSegmentEnd, Point) {\n    var dxc = Point[0] - LineSegmentStart[0];\n    var dyc = Point[1] - LineSegmentStart[1];\n    var dxl = LineSegmentEnd[0] - LineSegmentStart[0];\n    var dyl = LineSegmentEnd[1] - LineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return LineSegmentStart[0] <= Point[0] && Point[0] <= LineSegmentEnd[0];\n        } else {\n            return LineSegmentEnd[0] <= Point[0] && Point[0] <= LineSegmentStart[0];\n        }\n    } else if (dyl > 0) {\n        return LineSegmentStart[1] <= Point[1] && Point[1] <= LineSegmentEnd[1];\n    } else {\n        return LineSegmentEnd[1] <= Point[1] && Point[1] <= LineSegmentStart[1];\n    }\n}\n\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexport default booleanDisjoint;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, lineString, point } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, options);\n            // sectionLength\n            var sectionLength = distance(start, stop, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(\n                lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]),\n                lineString([start.geometry.coordinates, stop.geometry.coordinates])\n            );\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance(start, intersectPt, options);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default nearestPointOnLine;\n","import bearing from '@turf/bearing';\nimport destination from '@turf/destination';\nimport distance from '@turf/distance';\n\n/**\n * Takes two {@link Point|points} and returns a point midway between them.\n * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.\n *\n * @name midpoint\n * @param {Coord} point1 first point\n * @param {Coord} point2 second point\n * @returns {Feature<Point>} a point midway between `pt1` and `pt2`\n * @example\n * var point1 = turf.point([144.834823, -37.771257]);\n * var point2 = turf.point([145.14244, -37.830937]);\n *\n * var midpoint = turf.midpoint(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2, midpoint];\n * midpoint.properties['marker-color'] = '#f00';\n */\nfunction midpoint(point1, point2) {\n    var dist = distance(point1, point2);\n    var heading = bearing(point1, point2);\n    var midpoint = destination(point1, dist / 2, heading);\n\n    return midpoint;\n}\n\nexport default midpoint;\n","// Heavily inspired from works of @davidgilbertson on Github and `leaflet-geoman` project.\n\nimport { geojsonTypes } from \"@mapbox/mapbox-gl-draw/src/constants\";\n// import {\n//   bboxPolygon,\n//   booleanDisjoint,\n//   getCoords,\n//   distance,\n//   polygonToLine,\n//   nearestPointOnLine,\n//   midpoint,\n// } from \"@turf/turf\";\n\nimport bboxPolygon from \"@turf/bbox-polygon\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { getCoords } from \"@turf/invariant\";\nimport distance from \"@turf/distance\";\nimport polygonToLine from \"@turf/polygon-to-line\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport midpoint from \"@turf/midpoint\";\n\nexport const IDS = {\n  VERTICAL_GUIDE: \"VERTICAL_GUIDE\",\n  HORIZONTAL_GUIDE: \"HORIZONTAL_GUIDE\",\n};\n\nexport const addPointTovertices = (\n  map,\n  vertices,\n  coordinates,\n  forceInclusion\n) => {\n  const { width: w, height: h } = map.getCanvas();\n  // Just add verteices of features currently visible in viewport\n  const { x, y } = map.project(coordinates);\n  const pointIsOnTheScreen = x > 0 && x < w && y > 0 && y < h;\n\n  // But do add off-screen points if forced (e.g. for the current feature)\n  // So features will always snap to their own points\n  if (pointIsOnTheScreen || forceInclusion) {\n    vertices.push(coordinates);\n  }\n};\n\nexport const createSnapList = (map, draw, currentFeature) => {\n  // Get all drawn features\n  const features = draw.getAll().features;\n  const snapList = [];\n\n  // Get current bbox as polygon\n  const bboxAsPolygon = (() => {\n    const canvas = map.getCanvas(),\n      w = canvas.width,\n      h = canvas.height,\n      cUL = map.unproject([0, 0]).toArray(),\n      cUR = map.unproject([w, 0]).toArray(),\n      cLR = map.unproject([w, h]).toArray(),\n      cLL = map.unproject([0, h]).toArray();\n\n    return bboxPolygon([cLL, cUR].flat());\n  })();\n\n  const vertices = [];\n\n  // Keeps vertices for drwing guides\n  const addVerticesTovertices = (coordinates, isCurrentFeature = false) => {\n    if (!Array.isArray(coordinates)) throw Error(\"Your array is not an array\");\n\n    if (Array.isArray(coordinates[0])) {\n      // coordinates is an array of arrays, we must go deeper\n      coordinates.forEach((coord) => {\n        addVerticesTovertices(coord);\n      });\n    } else {\n      // If not an array of arrays, only consider arrays with two items\n      if (coordinates.length === 2) {\n        addPointTovertices(map, vertices, coordinates, isCurrentFeature);\n      }\n    }\n  };\n\n  features.forEach((feature) => {\n    // For currentfeature\n    if (feature.id === currentFeature.id) {\n      if (currentFeature.type === geojsonTypes.POLYGON) {\n        // For the current polygon, the last two points are the mouse position and back home\n        // so we chop those off (else we get vertices showing where the user clicked, even\n        // if they were just panning the map)\n        addVerticesTovertices(\n          feature.geometry.coordinates[0].slice(0, -2),\n          true\n        );\n      }\n      return;\n    }\n\n    // If this is re-running because a user is moving the map, the features might include\n    // vertices or the last leg of a polygon\n    if (\n      feature.id === IDS.HORIZONTAL_GUIDE ||\n      feature.id === IDS.VERTICAL_GUIDE\n    )\n      return;\n\n    addVerticesTovertices(feature.geometry.coordinates);\n\n    // If feature is currently on viewport add to snap list\n    if (!booleanDisjoint(bboxAsPolygon, feature)) {\n      snapList.push(feature);\n    }\n  });\n\n  return [snapList, vertices];\n};\n\nconst getNearbyvertices = (vertices, coords) => {\n  const verticals = [];\n  const horizontals = [];\n\n  vertices.forEach((vertex) => {\n    verticals.push(vertex[0]);\n    horizontals.push(vertex[1]);\n  });\n\n  const nearbyVerticalGuide = verticals.find(\n    (px) => Math.abs(px - coords.lng) < 0.009\n  );\n\n  const nearbyHorizontalGuide = horizontals.find(\n    (py) => Math.abs(py - coords.lat) < 0.009\n  );\n\n  return {\n    verticalPx: nearbyVerticalGuide,\n    horizontalPx: nearbyHorizontalGuide,\n  };\n};\n\nconst calcLayerDistances = (lngLat, layer) => {\n  // the point P which we want to snap (probpably the marker that is dragged)\n  const P = [lngLat.lng, lngLat.lat];\n\n  // is this a marker?\n  const isMarker = layer.geometry.type === \"Point\";\n  // is it a polygon?\n  const isPolygon = layer.geometry.type === \"Polygon\";\n\n  let lines = undefined;\n\n  // the coords of the layer\n  const latlngs = getCoords(layer);\n\n  if (isMarker) {\n    const [lng, lat] = latlngs;\n    // return the info for the marker, no more calculations needed\n    return {\n      latlng: { lng, lat },\n      distance: distance(latlngs, P),\n    };\n  }\n\n  if (isPolygon) lines = polygonToLine(layer);\n  else lines = layer;\n\n  const nearestPoint = nearestPointOnLine(lines, P);\n  const [lng, lat] = nearestPoint.geometry.coordinates;\n\n  return {\n    latlng: { lng, lat },\n    segment: lines.geometry.coordinates.slice(\n      nearestPoint.properties.index,\n      nearestPoint.properties.index + 2\n    ),\n    distance: nearestPoint.properties.dist,\n    isMarker,\n  };\n};\n\nconst calcClosestLayer = (lngLat, layers) => {\n  let closestLayer = {};\n\n  // loop through the layers\n  layers.forEach((layer, index) => {\n    // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n    const results = calcLayerDistances(lngLat, layer);\n\n    // save the info if it doesn't exist or if the distance is smaller than the previous one\n    if (\n      closestLayer.distance === undefined ||\n      results.distance < closestLayer.distance\n    ) {\n      closestLayer = results;\n      closestLayer.layer = layer;\n    }\n  });\n\n  // return the closest layer and it's data\n  // if there is no closest layer, return undefined\n  return closestLayer;\n};\n\n// minimal distance before marker snaps (in pixels)\nconst metersPerPixel = function (latitude, zoomLevel) {\n  const earthCircumference = 40075017;\n  const latitudeRadians = latitude * (Math.PI / 180);\n  return (\n    (earthCircumference * Math.cos(latitudeRadians)) /\n    Math.pow(2, zoomLevel + 8)\n  );\n};\n\n// we got the point we want to snap to (C), but we need to check if a coord of the polygon\n// receives priority over C as the snapping point. Let's check this here\nconst checkPrioritiySnapping = (closestLayer, snapOptions) => {\n  // A and B are the points of the closest segment to P (the marker position we want to snap)\n  const A = closestLayer.segment[0];\n  const B = closestLayer.segment[1];\n\n  // C is the point we would snap to on the segment.\n  // The closest point on the closest segment of the closest polygon to P. That's right.\n  const C = [closestLayer.latlng.lng, closestLayer.latlng.lat];\n\n  // distances from A to C and B to C to check which one is closer to C\n  const distanceAC = distance(A, C);\n  const distanceBC = distance(B, C);\n\n  // closest latlng of A and B to C\n  let closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n  // distance between closestVertexLatLng and C\n  let shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n  // snap to middle (M) of segment if option is enabled\n  if (snapOptions && snapOptions.snapToMidPoints) {\n    const M = midpoint(A, B).geometry.coordinates;\n    const distanceMC = distance(M, C);\n\n    if (distanceMC < distanceAC && distanceMC < distanceBC) {\n      // M is the nearest vertex\n      closestVertexLatLng = M;\n      shortestDistance = distanceMC;\n    }\n  }\n\n  // the distance that needs to be undercut to trigger priority\n  const priorityDistance = 1.25;\n\n  // the latlng we ultemately want to snap to\n  let snapLatlng;\n\n  // if C is closer to the closestVertexLatLng (A, B or M) than the snapDistance,\n  // the closestVertexLatLng has priority over C as the snapping point.\n  if (shortestDistance < priorityDistance) {\n    snapLatlng = closestVertexLatLng;\n  } else {\n    snapLatlng = C;\n  }\n\n  // return the copy of snapping point\n  const [lng, lat] = snapLatlng;\n  return { lng, lat };\n};\n\n/**\n * Returns snap points if there are any, otherwise the original lng/lat of the event\n * Also, defines if vertices should show on the state object\n *\n * Mutates the state object\n *\n * @param state\n * @param e\n * @returns {{lng: number, lat: number}}\n */\nexport const snap = (state, e) => {\n  let lng = e.lngLat.lng;\n  let lat = e.lngLat.lat;\n\n  // Holding alt bypasses all snapping\n  if (e.originalEvent.altKey) {\n    state.showVerticalSnapLine = false;\n    state.showHorizontalSnapLine = false;\n\n    return { lng, lat };\n  }\n\n  if (state.snapList.length <= 0) {\n    return false;\n  }\n\n  // snapping is on\n  let closestLayer, minDistance, snapLatLng;\n  if (state.options.snap) {\n    closestLayer = calcClosestLayer({ lng, lat }, state.snapList);\n\n    // if no layers found. Can happen when circle is the only visible layer on the map and the hidden snapping-border circle layer is also on the map\n    if (Object.keys(closestLayer).length === 0) {\n      return false;\n    }\n\n    const isMarker = closestLayer.isMarker;\n\n    if (!isMarker) {\n      snapLatLng = checkPrioritiySnapping(\n        closestLayer,\n        state.options.snapOptions\n      );\n      // snapLatLng = closestLayer.latlng;\n    } else {\n      snapLatLng = closestLayer.latlng;\n    }\n\n    minDistance =\n      ((state.options.snapOptions && state.options.snapOptions.snapPx) || 15) *\n      metersPerPixel(snapLatLng.lat, state.map.getZoom());\n  }\n\n  let verticalPx, horizontalPx;\n  if (state.options.guides) {\n    const nearestGuidline = getNearbyvertices(state.vertices, e.lngLat);\n\n    verticalPx = nearestGuidline.verticalPx;\n    horizontalPx = nearestGuidline.horizontalPx;\n\n    if (verticalPx) {\n      // Draw a line from top to bottom\n\n      const lngLatTop = { lng: verticalPx, lat: e.lngLat.lat + 10 };\n      const lngLatBottom = { lng: verticalPx, lat: e.lngLat.lat - 10 };\n\n      state.verticalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.verticalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    if (horizontalPx) {\n      // Draw a line from left to right\n\n      const lngLatTop = { lng: e.lngLat.lng + 10, lat: horizontalPx };\n      const lngLatBottom = { lng: e.lngLat.lng - 10, lat: horizontalPx };\n\n      state.horizontalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.horizontalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    state.showVerticalSnapLine = !!verticalPx;\n    state.showHorizontalSnapLine = !!horizontalPx;\n  }\n\n  if (closestLayer && closestLayer.distance * 1000 < minDistance) {\n    return snapLatLng;\n  } else if (verticalPx || horizontalPx) {\n    if (verticalPx) {\n      lng = verticalPx;\n    }\n    if (horizontalPx) {\n      lat = horizontalPx;\n    }\n    return { lng, lat };\n  } else {\n    return { lng, lat };\n  }\n};\n\nexport const getGuideFeature = (id) => ({\n  id,\n  type: geojsonTypes.FEATURE,\n  properties: {\n    isSnapGuide: \"true\", // for styling\n  },\n  geometry: {\n    type: geojsonTypes.LINE_STRING,\n    coordinates: [],\n  },\n});\n\nexport const shouldHideGuide = (state, geojson) => {\n  if (\n    geojson.properties.id === IDS.VERTICAL_GUIDE &&\n    (!state.options.guides || !state.showVerticalSnapLine)\n  ) {\n    return true;\n  }\n\n  if (\n    geojson.properties.id === IDS.HORIZONTAL_GUIDE &&\n    (!state.options.guides || !state.showHorizontalSnapLine)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n","import { geojsonTypes, cursors } from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawPoint from \"@mapbox/mapbox-gl-draw/src/modes/draw_point\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapPointMode = { ...DrawPoint };\n\nSnapPointMode.onSetup = function (options) {\n  const point = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POINT,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(point);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n\n  const state = {\n    map: this.map,\n    point,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPointMode.onClick = function (state) {\n  // We mock out e with the rounded lng/lat then call DrawPoint with it\n  DrawPoint.onClick.call(this, state, {\n    lngLat: {\n      lng: state.snappedLng,\n      lat: state.snappedLat,\n    },\n  });\n};\n\nSnapPointMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPoint.toDisplayFeatures\nSnapPointMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPoint.onStop\nSnapPointMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.onStop.call(this, state);\n};\n\nexport default SnapPointMode;\n","import {\n  geojsonTypes,\n  modes,\n  cursors,\n} from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawLine from \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapLineMode = { ...DrawLine };\n\nSnapLineMode.onSetup = function (options) {\n  const line = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.LINE_STRING,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(line);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n\n  const state = {\n    map: this.map,\n    line,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n    direction: \"forward\", // expected by DrawLineString\n  };\n\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapLineMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  // Note: not bothering with 'direction'\n  if (state.currentVertexPosition > 0) {\n    const lastVertex = state.line.coordinates[state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.line.id],\n      });\n    }\n  }\n\n  // const point = state.map.project({ lng: lng, lat: lat });\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n};\n\nSnapLineMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawLine.toDisplayFeatures\nSnapLineMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawLine.onStop\nSnapLineMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.onStop.call(this, state);\n};\n\nexport default SnapLineMode;\n","import {\n  geojsonTypes,\n  modes,\n  cursors,\n} from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawPolygon from \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapPolygonMode = { ...DrawPolygon };\n\nSnapPolygonMode.onSetup = function (options) {\n  const polygon = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POLYGON,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(polygon);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, polygon);\n\n  const state = {\n    map: this.map,\n    polygon,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(\n      this.map,\n      this._ctx.api,\n      polygon\n    );\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPolygonMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  if (state.currentVertexPosition > 0) {\n    const lastVertex =\n      state.polygon.coordinates[0][state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.polygon.id],\n      });\n    }\n  }\n\n  // const point = state.map.project();\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n};\n\nSnapPolygonMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPolygon.toDisplayFeatures\nSnapPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPolygon.onStop\nSnapPolygonMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.onStop.call(this, state);\n};\n\nexport default SnapPolygonMode;\n","import theme from '@mapbox/mapbox-gl-draw/src/lib/theme';\n\nconst modifiedDefaultStyles = theme.map(defaultStyle => {\n  if (defaultStyle.id === 'gl-draw-line-inactive') {\n    return {\n      ...defaultStyle,\n      filter: [\n        ...defaultStyle.filter,\n        ['!=', 'user_isSnapGuide', 'true'],\n      ],\n    };\n  }\n\n  return defaultStyle;\n});\n\nconst customDrawStyles = [\n  ...modifiedDefaultStyles,\n  {\n    id: \"guide\",\n    type: \"line\",\n    filter: [\n      \"all\",\n      [\"==\", \"$type\", \"LineString\"],\n      [\"==\", \"user_isSnapGuide\", \"true\"],\n    ],\n    layout: {\n      \"line-cap\": \"round\",\n      \"line-join\": \"round\",\n    },\n    paint: {\n      \"line-color\": \"#c00c00\",\n      \"line-width\": 1,\n      \"line-dasharray\": [5, 5],\n    },\n  },\n];\n\nexport default customDrawStyles;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__759__;","module.exports = __WEBPACK_EXTERNAL_MODULE__583__;","module.exports = __WEBPACK_EXTERNAL_MODULE__403__;","module.exports = __WEBPACK_EXTERNAL_MODULE__556__;","module.exports = __WEBPACK_EXTERNAL_MODULE__227__;","module.exports = __WEBPACK_EXTERNAL_MODULE__391__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(990);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}